## 解题思路

## 1. 递归

考虑最后一个数，选择 + 或 -，则
$$dfs(idx+1) = dfs(idx, target-nums[i]) + dfs(idx, target+nums[i])$$

然后是边界条件判断，如果 idx < 0，意味着所有数都被选择 + 或 - 了，那么只有 target == 0 才能认为是一种有效的组合

最终写出代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findTargetSumWays = function(nums, target) {
  const dfs = (idx, target) => {
      if(idx < 0) {
          return target === 0;
      }

      return dfs(idx-1, target-nums[idx]) + dfs(idx-1, target+nums[idx]);
  }
  return dfs(nums.length-1, target);
}
```

## 2. 递归 => DP

根据上述递归函数，映射到对应的DP方程 $$dp[idx+1][target] = dp[idx][target-nums[i]] + dp[idx][target+nums[i]]$$

但是注意，target 的取值范围为 $$[-Sum(nums), Sum(nums)]$$
因此DP数组的第二维度长度要初始化为 `2 * sum(nums) + 1`

同时，由于数组起始位置是0，没有负数，因此我们需要对结果取余

最终得到代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findTargetSumWays = function(nums, target) {
    if(nums.length === 1) {
        return +(nums[0] === target || nums[0] === -target);
    }
    const maxNum = nums.reduce((res, cur) => res + cur, 0);
    const len = maxNum * 2 + 1;
    const dp = [...Array(nums.length + 1)].map(() => [...Array(len)].fill(0));

    dp[0][0] = 1;

    for(let i = 0; i < nums.length; i++) {
        for(let j = 0; j < len; j++) {
            dp[i+1][j] = dp[i][(j - nums[i] + len) % len] + dp[i][(j + nums[i]) % len]
        }
    }
    return dp[nums.length][(target + len) % len];
};
```

## 3. 优化 DP

我们再来分析下，能否规避掉麻烦的负数处理？（对DP很不友好）

假设我们选取了一种方案，其中所有正数的和为 `p`

同时我们假设 nums 的所有数字如果都选 +，和为 `s`

那么

$$
  p - (s-p) = target
$$

可以推导出

$$
  p = \frac{(target + s)}{2}
$$

另外，我们可以将 dp 数组的空间复杂度优化为 $$O(target+s)$$,详细计算过程可参考[视频](https://www.bilibili.com/video/BV16Y411v7Y6/?p=18&spm_id_from=pageDriver),这里不再赘述

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findTargetSumWays = function(nums, target) {
  const sum = nums.reduce((res, cur) => res + cur, 0);
  target += sum;
  // 因为 p 为正整数，所以可预剪枝部分 case
  if(target < 0 || target & 1) {
      return 0;
  }
  target >>= 1;
  // f[i+1][t] = f[i][t] + f[i][t - nums[i]]
  const dp = [...Array(target + 1)].fill(0);
  dp[0] = 1;
  for(let i = 0; i < nums.length; i++) {
      for(let j = target; j >= nums[i]; j--) {
          dp[j] = dp[j] + dp[j - nums[i]];
      }
  }
  return dp[target];
}
```