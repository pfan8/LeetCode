## 解题思路

经典 **选和不选** 思想的 `DP` 问题，包括 `递归 -> DP` 的过程，可参考[灵神的视频](https://www.bilibili.com/video/BV1Xj411K7oF/?spm_id_from=pageDriver)（我们没必要重复产出了对吧 XD）

除此之外，该题有几个trick：

1. 空间状态优化后，只保留 2 个元素存储前 `n-2` 和 `n-1` 位置的最大值
2. 初始化 `n-2` 和 `n-1` 的值为 `0`，直接遍历数组每个元素，根据公式 $$ dp[n] = max(dp[n-1], dp[n-2] + nums[i]) $$ 公式可以得到，如果数组长度只有1或者2，也能满足该公式（i.e. 不用做额外的判断了）
3. 遍历过程中，通过交换语法（每个语言会不同）直接交换 `n-2` 和 `n-1` 的元素，但是需要注意先覆盖 `n-1`，因为计算 `n-1` 的过程中需要前一轮的 `n-2` 元素，如果先覆盖 `n-2`，就变为新一轮的 `n-2` 了

具体实现(假设 `x1` 为 `n-2`，`x2` 为 `n-1`)

### javascript
```javascript
  [x2, x1] = [Math.max(x2, x1 + nums[i]), x2];
```

### python
```python
  x2, x1 = max(x2, x1 + nums[i]), x2
```