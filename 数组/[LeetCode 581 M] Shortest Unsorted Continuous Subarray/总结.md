## 解题思路
总结：对于数组的题，由于数组是固定的，通常可以考虑cache的方式节约时间（DP思想），并结合指针。另外应当联想到使用stack，queue等数据结构辅助，因为FIFO和FILO的特性很适合解决某些需求

做法有4种：

1. 暴力破解，时间复杂度$O(N^2)$
2. 排序：拷贝数组，并对新数组排序，然后再跟原数组遍历比较，找到第一个不order的左右index即可
    + 时间复杂度：$O(Nlog(N))$
    + 空间复杂度：$O(N)$
3. `Stack`：因为subArray的左右均是排好序的，可以利用这个特性压栈。以left为例，如果栈顶元素大于当前数组元素，则出栈，从而能够找到最大长度的已排好序的left位置（即最小的stack大小），right则类似的，通过反向遍历获取
    + 时间复杂度：$O(N)$
    + 空间复杂度：$O(N)$
4. 指针`Pointer` + `Cache`：由于需要找到最小的乱序数组(命名为subArr)，subArr左边必然全部都是排好序的，而且必subArr的最小值还小（<=），所以可以通过Cache标记最小值，数组从左往右遍历，乱序数组subArr中最小的元素必然是比前一个元素小的元素，不然subArr就是单调递增的了，因此只需要在nums[i] > nums[i+1]的时候，另`minNum = Math.min(minNum, nums[i+1])`即可。flow为
   1. 第一遍遍历数组，找到`minNum`
   2. 第二遍遍历数组，找到subArr的起始位置`start`
    
    同样对称的flow得到`maxNum`和`end`，从而结果就等于`end-start+1`，但是要注意，因为数组可能找不到乱序的位置，这时候end就会小于start，所以还要判断`start` < `end`，否则返回0
    + 时间复杂度：$O(N)$
    + 空间复杂度：$O(1)$
